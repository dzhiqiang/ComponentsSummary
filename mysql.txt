mysql的锁：
https://blog.csdn.net/zcl_love_wx/article/details/81983267
行级锁：不是由mysql决定的，而是由存储引擎决定的，innodb
优点：粒度小，征用率低，并发高。
缺点：实现复杂，开销大，加锁慢。
InnoDB的行级锁定同样分为两种类型：共享锁和排他锁。
InnoDB也同样使用了**意向锁（表级锁定）**的概念，也就有了意向共享锁和意向排他锁这两种。
意向锁的概念是如果一个事务在获取资源时，如果遇到自己的资源已经被排它锁占用的时候，该事务可以在需要锁定行的表上添加一个合适的意向锁，如果需要一个共享锁，那么就在表面添加一个意向共享锁。
如果需要在某行添加排它锁的话，则先在表面添加一个意向排它锁。
意向锁：意向锁是锁表，其他事物在申请表锁的时候，不用查找具体行的锁。为了防止表级别上的请求冲突。
如何实现行锁：通过在索引上的索引项加锁实现的，如果不使用索引的话，会使用表锁。因为是在索引上加锁，及时访问不同的行，也会产生冲突。
当表中有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外不论是使用主键索引，唯一索引，或者普通索引，InnoDB都会使用行锁来对数据加锁。
隐式加锁：
mysql加锁底层：
1：InnoDB自动加意向锁
2：对于update,insert,delete会加排它锁（x）
3: 对于select语句不会加任何锁

显示加锁：
共享锁（S）：select * from table_name ... lock in share mode
排它锁（X）：select * from table_name ... for update



间隙锁：
InnoDB的锁定规则是通过指向数据记录的第一个索引键之前和后一个索引建之后的空域上标记锁定信息实现的。这样的锁定实现NEXT-KEY locking（间隙锁）。在进行范围查找的话，他会锁定整个范围，及时这个键不存在
select * from emp where empid > 100 for update，如果empid = 101不存在，但是插入empid = 101的记录也是插入不进去的

间隙锁的缺点：
因为是范围锁定，不存在的值也不能插入，范围比较大，导致不能插入数据。
优点：防止幻读。
唯一主键：如果查询条件的主键存在只会产生行锁，如果不存在会产生间隙锁，范围是前一个主键和后一个主键，范围查找也会产生间隙锁。
普通索引：不管何种查询，只要加锁，都会产生间隙锁，锁的范围是索引的前一个值和后一个值。同时普通索引此范围对应的主键也有范围锁。-

多版本并发控制-MVCC
通过保存数据某个时间点的快照实现的，很小的开销就能实现非锁定读。缺点增加了相应的字段存储数据，每次查询需要比较版本号，innodb需要定时清理不需要的版本，收回空间，也是有一定的开销的。
通过查找undolog实现的,undolog是存储修改前的记录
增加字段DB_TRX_ID事务id,DB_ROLL_PTR回滚id,DB_ROW_ID:递增id,当没有指定主键的时候，会生成一个DB_ROW_ID.


InnoDB和myisam的区别
 1:InnoDB 支持事务，MyISAM 不支持事务
 2:InnoDB 支持外键，而 MyISAM 不支持
 3:表锁差异,只支持表级锁,行级锁
InnoDB为什么用b+树

InnoDB回复过程
https://www.jianshu.com/p/80c28fe4e2fe
InnoDB的数据恢复是一个很复杂的过程，这个恢复过程需要redo log、binlog、undo log等参与。这里把InnoDB的恢复过程主要划分为两个阶段:
第一阶段主要依赖于redo log的恢复；
而第二阶段，恰恰需要binlog和undo log的共同参与。
一、依赖redo log进行恢复
第一阶段：数据库启动后，InnoDB会根据checkpoint找到最后一次checkpoint的LSN,然后根据LSN获取重做的日志，接着解析获取的日志并且保存到一个哈希表中，读取redolog日志，读取相关页的恢复。
第二阶段：binlog和undo log共同参与
	1）根据binlog获取所有可能没有提交事务的xid列表
	2）根据undo中的信息构造所有未提交事务链表，最后通过上面两部分协调判断事务是否可以提交。



Mysql底层线程：
Master Thread线程：负责数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（insert buffer）undolog页的回收等
IO Thread:负责IO请求的回调处理。主从同步。
Purge Thread:删除undolog日志
Page Cleaner Thread:将之前版本的脏页的刷新

内存：
页的大小默认为16kb
1：缓冲池：数据页类型有：索引页，数据页，undo页，插入缓冲（insert buffer）,自适应哈希索引，InnoDB存储的锁信息，数据字典信息等
2: 缓冲池管理：LRU(Latest Recent Used)最近最少使用，优化处理，最近访问的页放入到midpoint位置（5/8位置）
3：重做日志缓冲：先放入到缓冲池，已一定的频率刷新到重做日志文件。
	刷新到文件条件
	1）masterThread 每秒刷新一次
	2）当事务提交的时候
	3）当缓冲池大于1/2时。
4：额外的内存池
5：checkpoint技术
为了防止数据丢失使用（write ahead log）策略，事务提交时先写重做日志，在修改页。
checkpoint：1）缓冲池不够用时，讲脏页刷新到磁盘2）重做日志不可用时，刷新脏页
通过LSN（8字节）标志版本：每个页中都有LSN，重做日志中也有LSN，checkpoint也有LSN.
什么时候进行checkpoint:
1)主线程每秒或者10秒，将一定比例的脏页刷新到数据库
2)FLUSH_LRU_LIST Checkpint：通过检查LRU列表是否有足够的空间页来进行checkpoint的
3）重做日期不可用的情况（重做日志比较大），强制刷新
4）脏页太多，也会刷新，默认75%

InnoDB特性：
1：插入缓冲，满足2个条件：1）索引是辅助索引2）索引不是唯一的
坏处：发生宕机时，部分insertbuffer并没有插入到对应的索引中，导致回复时间长
2：ChangeBuffer
可以对insert ,delete,update进行缓冲，分别为insert buffer,delete buffer,purge buffer
3:两次写（doublewrite）
InnoDB存储引擎的是数据页的可靠性
脏页不直接写入磁盘而是直接写入doublewritebuffer,写入buffer后在写入表共享空间，然后同步到磁盘。
4：自适应哈希索引
B+树的高度一般为3-4。需要3-4次查询。InnoDB自动判断如果能带来性能的提升则创建自适应哈希（AHI）,不会每个节点创建哈希，而是根据访问频率和模式自动为热点页建立
创建条件：1）已该模式访问了100次2）页通过该模式访问了N次，其中N=页中记录*1/16
5：异步IO
Sql语句需要查询多个页，没必要等待其他页返回，可以直接请求读取其他页，而且还有进行IO merge操作，如果发现连续的页，那么会读取合并后页的大小
6：刷新邻接页
刷新脏页时，InnoDB存储引擎检测该页的所在区的所有页，如果是脏页则一起刷新。

文件系统：
1：日志文件：错误日志，二进制日志，慢查询日志，查询日志。
主要看二进制日志（binary log）
作用：
恢复：某些数据的恢复需要二进制日志
复制：通过复制和执行二进制日志使一台远程的mysql数据库与一台Mysql数据库进行实时同步
审计：判断是否有对数据库的攻击
当使用支持事务的数据库引擎时，所有未提交的二进制日志会被记录到一个缓存中取，等该事务提交时直接将缓冲的二进制文件写入二进制文件中。
并不是每次写都会同步到磁盘
如果sysc_binlog默认值为0，不会立即同步到磁盘，会有系统缓存，设置为1的话会立即写入磁盘。
binlog_format:statement,row,mixed
1)statement:记录日志的逻辑sql语句
2）row:记录行更改的条件
3）mixed模式：默认使用statement格式进行二进制文件存储，但在一些情况下会使用row
	1)使用了UUID(),USER(),CURRENT_USER(),FOUND_ROWS()
	2)使用了INSERT DELAY语句
	3)使用了用户定义的函数
	5)使用了临时表
2:配置文件
3：套接字文件
4：pid文件
5：表结构文件
6：InnoDB存储引擎文件
	表空间文件：可以通过设置innodb_file_per_table=ON,每个表都存储单独的文件，文件中存储此表的数据，索引和插入缓冲等信息
	重做事务文件：重做日志文件有组的概念，每组默认2个文件，用于循环写入。记录的是页的更改的物理情况。二进制文件仅在事务提交前提交，只写入磁盘一次。在事务进行过程中，会有重做日志被写入文件。
	重做日志是先写入缓冲中的，然后按照一定的顺序写入文件，每次写入磁盘是512字节， 写入是成功的，不用双写。
	重做日期写入磁盘的配置：innodb_flush_log_at_trx_commit:
	0:每次都写入重做日志的缓冲中，master线程刷新到日志中
	1:每次提交事务都写入文件，并调用fsync（直接从文件系统的缓存中写入磁盘）
	2:每次提交事务都写入文件，但是不调用fsync及写入文件系统缓冲中。
表
1：索引组织表
	表是根据主键顺序存放的，如果没定义主键会是第一个非空唯一索引定义为主键，还没有的话会自动创建一个6字节的指针。
2：innodb逻辑存储结构
	所有数据都被逻辑存放在一个空间中，称为表空间。表空间又由段（segment），区(extent),页（page）组成。
	1表空间：初始大小为58M，undolog日志会存入表空间
	2段：数据段则是叶子节点，索引段为B+树的非叶子节点
	3区：任何区的大小为1M，为了保证区的大小为页为连续的，一次申请4-5个区。1个区有64个连续的页。
	4页：是磁盘的最小单位，默认16K，数据页，undo页，系统页。。。
	5行：每页最多存放的行数为16kb/2 - 200 行记录及7992行
3：行记录格式
	compact行记录格式：不记录null值
		变长字段长度列表：非空的字段长度逆序存放，255以内是1个字节，255以外用2个字节。
		NULL标志位：指示了改行数据中是否有NULL值，有则用1
		头信息：固定40bit
4：行溢出数据：因为一个数据页16k及16384字节，一行记录最长为65532字节，其他字节存放在页类型为Uncompress BLOB页中。
5：InnoDB数据页结构
	1)File Header(文件头) 38个字节
		关键属性：FIL_PAGE_OFFSET:表空间中页的偏移量。FIL_PAGE_LSN:修改该页最后被修改的LSN
	2)Page Header(页头) 56个字节，都是关于记录的配置
		关键属性：PAGE_HEAP_TOP:记录第一个记录的指针。
				  PAGE_N_HEAP:堆中的记录数
				  PAGE_GARBAGE:已删除的记录的字节数，delete flag为1记录的总字节数
				  PAGE_N_DIRECTION:一个方向连续插入记录的数量
				  PAGE_N_RECS:该页中记录的数量
	3)Infimun和Supremum Records 前者记录该页中笔任何主键值要小的值，后者记录比任何可能大的值还要大的值。
	4)User Records(用户记录及行记录)：行记录的内容
	5)Free Space(空闲空间)：空闲的行的内容
	6)Page Directory(页目录)：
	7)File Trailer(文件结尾信息)：用来保证数据的完整行
6：分区
	mysql支持的分区：分区列必须是唯一索引的一个组成部分，如果没有唯一索引那么任何列都可以分区
	RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区
		partition p0 values less than (10)
		partition p1 values less than (20)这样就是连续的分块的分区
	List分区：和RANGE分区类似，只是LIST分区面向的是离散的值
		partition p0 values in(1,3,5,7,9)
		partition p0 values in(2,4,6,8,10)离散的非连续的
	HASH分区：根据用户定义的表达式的返回值来进行分区，返回值不能是负数
		partition by hash(year(b))
		partitions 4;为了均匀分布到各个分区
	KEY分区：根据MySQL数据库提供的哈希函数来进行分区。
		partition by key(b)
		partitions 4;为了均匀分布到各个分区
7:索引和算法
	B+树索引
		聚集索引：是按照表的主键构建的一个B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。数据页也是索引的一部分，数据页是通过双向链表来进行链接的。
		每张表只有一个聚集索引。查询优化器倾向于采用聚集索引。
		辅助索引（非聚集索引）：叶子节点并不包含记录的全部数据，叶子节点包含键值和书签，书签会告诉InnDB存储引擎哪里可以找到与索引相对应的行数据。
		B+树索引的分裂：目前默认的是50%分裂页的操作，但是如果遇到顺序递增的索引，那么原有页的使用量只有50%，容易造成浪费
		通过记录上一次插入记录的位置和方向决定是否从50%处分裂，并带着上一次记录一起分裂
	B+树的索引
		
	全文索引
	哈希索引

	
		
	

























