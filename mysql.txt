mysql的锁：
https://blog.csdn.net/zcl_love_wx/article/details/81983267
行级锁：不是由mysql决定的，而是由存储引擎决定的，innodb
优点：粒度小，征用率低，并发高。
缺点：实现复杂，开销大，加锁慢。
InnoDB的行级锁定同样分为两种类型：共享锁（S）和排他锁（X）。
InnoDB也同样使用了**意向锁（表级锁定）**的概念，也就有了意向共享锁和意向排他锁这两种。
意向锁的概念是如果一个事务在获取资源时，如果遇到自己的资源已经被排它锁占用的时候，该事务可以在需要锁定行的表上添加一个合适的意向锁，如果需要一个共享锁，那么就在表面添加一个意向共享锁。
如果需要在某行添加排它锁的话，则先在表面添加一个意向排它锁。
意向锁：意向锁是锁表，其他事物在申请表锁的时候，不用查找具体行的锁。为了防止表级别上的请求冲突。
如何实现行锁：通过在索引上的索引项加锁实现的，如果不使用索引的话，会使用表锁。因为是在索引上加锁，及时访问不同的行，也会产生冲突。
当表中有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外不论是使用主键索引，唯一索引，或者普通索引，InnoDB都会使用行锁来对数据加锁。
隐式加锁：
mysql加锁底层：
1：InnoDB自动加意向锁
2：对于update,insert,delete会加排它锁（x）
3: 对于select语句不会加任何锁

显示加锁：
共享锁（S）：select * from table_name ... lock in share mode
排它锁（X）：select * from table_name ... for update



间隙锁：
InnoDB的锁定规则是通过指向数据记录的第一个索引键之前和后一个索引建之后的空域上标记锁定信息实现的。这样的锁定实现NEXT-KEY locking（间隙锁）。在进行范围查找的话，他会锁定整个范围，及时这个键不存在
select * from emp where empid > 100 for update，如果empid = 101不存在，但是插入empid = 101的记录也是插入不进去的

间隙锁的缺点：
因为是范围锁定，不存在的值也不能插入，范围比较大，导致不能插入数据。
优点：防止幻读。
唯一主键：如果查询条件的主键存在只会产生行锁，如果不存在会产生间隙锁，范围是前一个主键和后一个主键，范围查找也会产生间隙锁。
普通索引：不管何种查询，只要加锁，都会产生间隙锁，锁的范围是索引的前一个值和后一个值。同时普通索引此范围对应的主键也有范围锁。-

多版本并发控制-MVCC-一致性非锁定读的解决方案
通过保存数据某个时间点的快照实现的，很小的开销就能实现非锁定读。缺点增加了相应的字段存储数据，每次查询需要比较版本号，innodb需要定时清理不需要的版本，收回空间，也是有一定的开销的。
通过查找undolog实现的,undolog是存储修改前的记录
增加字段DB_TRX_ID事务id,DB_ROLL_PTR回滚id,DB_ROW_ID:递增id,当没有指定主键的时候，会生成一个DB_ROW_ID.

锁的处理：
解决死锁的方式可以使用等待超时机制，超过阈值其中一个事务回滚。回滚对象可能采用了FIFO的策略，可能回滚的事务占用了较多的UNDO log,采用这种方式不算太合适了
采用wait-for graph（等待图）的方式来进行死锁检测。判断等待锁的事务是否存在回路，如果存在回路则回滚undo log较少的事务

锁升级：innodb不会对锁升级操作，SQL Server会根据锁记录的条数5000和锁占用内存的比例40%就会发生所升级

事务：必须要满足ACID的特性
A:原子性，数据库事务是不可分割的工作单位，只有是事务中所有的数据库操作都执行成功才算做整个事务成功。
C：一致性,事务讲数据库从一种状态转变为下一种一致的状态。
I：隔离性，事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，及该事务提交前对其他事务都不可见。
D：持久性，事务一旦提交，起结果就是永久的。及时发生宕机等故障，数据库也能讲数据恢复。
分类：
	1）扁平事务：比如一个事务中做3件事情，那么回滚的话全部回滚
	2）带有保存点的扁平事务：比如一个事务中做3件事情，前2个执行了，可以保存，回滚的话只回滚到保存点，接着继续执行
	3）链事务：链式事务提交一个事务时，释放不需要的数据对象，将必要的处理上线文隐式的传给下一个要开始的事务。提交事务的操作和下一个事务操作合并一个原子操作。
		回滚的话只能在本事务回滚
	4）嵌套事务：是一个层次结构框架。有一个顶层事务控制着各个层次的事务。顶层之下的事务称为子事务。
	5）分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在的位置访问网络中的不同节点。
事务的实现：
1）redolog:
redo log 称作重做日志用来保证事务的原子性和持久性。包括2个部分：内存中的重做日志缓冲，其是易失的，二是重做日志文件，其是持久性的。
Innodb存储引擎，通过提交必须记录日志（Force Log at Commit）机制实现事务的持久性，重做日期缓冲要是写入磁盘需要调用fsync操作，可以通过参数的配置决定什么情况进行写入inndodb_flush_log_at_trx_commit控制
0：表示事务提交是不进行写入重做日志 文件，通过master thread 中完成，而master thread 是1秒刷新一次
1：事务提交时就进行一次fsycn
2: 表示会谢日重做日期文件中，但是仅仅是写入文件系统的缓存中，并不用进行fsync操作
重做日期都是以512字节存储的，头12字节，尾8字节，数据492字节。磁盘每次提交必须是512字节，所以不用doublewrite

LSN:含义有：1）重做日志写入的总量2）checkpoint的位置3）页的版本。LSN表示事务写入重做日志的总量，单位是字节。
LSN会存在每个页中，如果页中的LSN小于重做日志的LSN，则此页需要恢复。
恢复：
可以使用redolog日志进行恢复，因为存储的是逻辑日志，所以恢复速度比较快。
会查看数据checkpoint的LSN,恢复当时的LSN大小到redolog的LSN大小

undolog
redolog日志记录了事务的行为，可以很好的通过对页进行重做，但是事务如果需要回滚，则需要undo.1)遇到事务失败了2）或者直接回滚操作
redo存放在redolog文件中，而undolo存放在数据库内部的一个特殊段（segment）中,这个段是undo段。
作用：1）可以利用undolog回滚到修改之前的样子2）可以实现非锁定读


InnoDB和myisam的区别
 1:InnoDB 支持事务，MyISAM 不支持事务
 2:InnoDB 支持外键，而 MyISAM 不支持
 3:表锁差异,只支持表级锁,行级锁
InnoDB为什么用b+树

InnoDB回复过程
https://www.jianshu.com/p/80c28fe4e2fe
InnoDB的数据恢复是一个很复杂的过程，这个恢复过程需要redo log、binlog、undo log等参与。这里把InnoDB的恢复过程主要划分为两个阶段:
第一阶段主要依赖于redo log的恢复；
而第二阶段，恰恰需要binlog和undo log的共同参与。
一、依赖redo log进行恢复
第一阶段：数据库启动后，InnoDB会根据checkpoint找到最后一次checkpoint的LSN,然后根据LSN获取重做的日志，接着解析获取的日志并且保存到一个哈希表中，读取redolog日志，读取相关页的恢复。
第二阶段：binlog和undo log共同参与
	1）根据binlog获取所有可能没有提交事务的xid列表
	2）根据undo中的信息构造所有未提交事务链表，最后通过上面两部分协调判断事务是否可以提交。



Mysql底层线程：
Master Thread线程：负责数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（insert buffer）undolog页的回收等
IO Thread:负责IO请求的回调处理。主从同步。
Purge Thread:删除undolog日志
Page Cleaner Thread:将之前版本的脏页的刷新

内存：
页的大小默认为16kb
1：缓冲池：数据页类型有：索引页，数据页，undo页，插入缓冲（insert buffer）,自适应哈希索引，InnoDB存储的锁信息，数据字典信息等
2: 缓冲池管理：LRU(Latest Recent Used)最近最少使用，优化处理，最近访问的页放入到midpoint位置（5/8位置）
3：重做日志缓冲：先放入到缓冲池，已一定的频率刷新到重做日志文件。
	刷新到文件条件
	1）masterThread 每秒刷新一次
	2）当事务提交的时候
	3）当缓冲池大于1/2时。
4：额外的内存池
5：checkpoint技术
为了防止数据丢失使用（write ahead log）策略，事务提交时先写重做日志，在修改页。
checkpoint：1）缓冲池不够用时，讲脏页刷新到磁盘2）重做日志不可用时，刷新脏页
通过LSN（8字节）标志版本：每个页中都有LSN，重做日志中也有LSN，checkpoint也有LSN.
什么时候进行checkpoint:
1)主线程每秒或者10秒，将一定比例的脏页刷新到数据库
2)FLUSH_LRU_LIST Checkpint：通过检查LRU列表是否有足够的空间页来进行checkpoint的
3）重做日期不可用的情况（重做日志比较大），强制刷新
4）脏页太多，也会刷新，默认75%

InnoDB特性：
1：插入缓冲，满足2个条件：1）索引是辅助索引2）索引不是唯一的
坏处：发生宕机时，部分insertbuffer并没有插入到对应的索引中，导致回复时间长
2：ChangeBuffer
可以对insert ,delete,update进行缓冲，分别为insert buffer,delete buffer,purge buffer
3:两次写（doublewrite）
InnoDB存储引擎的是数据页的可靠性
脏页不直接写入磁盘而是直接写入doublewritebuffer,写入buffer后在写入表共享空间，然后同步到磁盘。
4：自适应哈希索引
B+树的高度一般为3-4。需要3-4次查询。InnoDB自动判断如果能带来性能的提升则创建自适应哈希（AHI）,不会每个节点创建哈希，而是根据访问频率和模式自动为热点页建立
创建条件：1）已该模式访问了100次2）页通过该模式访问了N次，其中N=页中记录*1/16
5：异步IO
Sql语句需要查询多个页，没必要等待其他页返回，可以直接请求读取其他页，而且还有进行IO merge操作，如果发现连续的页，那么会读取合并后页的大小
6：刷新邻接页
刷新脏页时，InnoDB存储引擎检测该页的所在区的所有页，如果是脏页则一起刷新。

文件系统：
1：日志文件：错误日志，二进制日志，慢查询日志，查询日志。
主要看二进制日志（binary log）
作用：
恢复：某些数据的恢复需要二进制日志
复制：通过复制和执行二进制日志使一台远程的mysql数据库与一台Mysql数据库进行实时同步
审计：判断是否有对数据库的攻击
当使用支持事务的数据库引擎时，所有未提交的二进制日志会被记录到一个缓存中取，等该事务提交时直接将缓冲的二进制文件写入二进制文件中。
并不是每次写都会同步到磁盘
如果sysc_binlog默认值为0，不会立即同步到磁盘，会有系统缓存，设置为1的话会立即写入磁盘。
binlog_format:statement,row,mixed
1)statement:记录日志的逻辑sql语句
2）row:记录行更改的条件
3）mixed模式：默认使用statement格式进行二进制文件存储，但在一些情况下会使用row
	1)使用了UUID(),USER(),CURRENT_USER(),FOUND_ROWS()
	2)使用了INSERT DELAY语句
	3)使用了用户定义的函数
	5)使用了临时表
2:配置文件
3：套接字文件
4：pid文件
5：表结构文件
6：InnoDB存储引擎文件
	表空间文件：可以通过设置innodb_file_per_table=ON,每个表都存储单独的文件，文件中存储此表的数据，索引和插入缓冲等信息
	重做事务文件：重做日志文件有组的概念，每组默认2个文件，用于循环写入。记录的是页的更改的物理情况。二进制文件仅在事务提交前提交，只写入磁盘一次。在事务进行过程中，会有重做日志被写入文件。
	重做日志是先写入缓冲中的，然后按照一定的顺序写入文件，每次写入磁盘是512字节， 写入是成功的，不用双写。
	重做日期写入磁盘的配置：innodb_flush_log_at_trx_commit:
	0:每次都写入重做日志的缓冲中，master线程刷新到日志中
	1:每次提交事务都写入文件，并调用fsync（直接从文件系统的缓存中写入磁盘）
	2:每次提交事务都写入文件，但是不调用fsync及写入文件系统缓冲中。
表
1：索引组织表
	表是根据主键顺序存放的，如果没定义主键会是第一个非空唯一索引定义为主键，还没有的话会自动创建一个6字节的指针。
2：innodb逻辑存储结构
	所有数据都被逻辑存放在一个空间中，称为表空间。表空间又由段（segment），区(extent),页（page）组成。
	1表空间：初始大小为58M，undolog日志会存入表空间
	2段：数据段则是叶子节点，索引段为B+树的非叶子节点
	3区：任何区的大小为1M，为了保证区的大小为页为连续的，一次申请4-5个区。1个区有64个连续的页。
	4页：是磁盘的最小单位，默认16K，数据页，undo页，系统页。。。
	5行：每页最多存放的行数为16kb/2 - 200 行记录及7992行
3：行记录格式
	compact行记录格式：不记录null值
		变长字段长度列表：非空的字段长度逆序存放，255以内是1个字节，255以外用2个字节。
		NULL标志位：指示了改行数据中是否有NULL值，有则用1
		头信息：固定40bit
4：行溢出数据：因为一个数据页16k及16384字节，一行记录最长为65532字节，其他字节存放在页类型为Uncompress BLOB页中。
5：InnoDB数据页结构
	1)File Header(文件头) 38个字节
		关键属性：FIL_PAGE_OFFSET:表空间中页的偏移量。FIL_PAGE_LSN:修改该页最后被修改的LSN
	2)Page Header(页头) 56个字节，都是关于记录的配置
		关键属性：PAGE_HEAP_TOP:记录第一个记录的指针。
				  PAGE_N_HEAP:堆中的记录数
				  PAGE_GARBAGE:已删除的记录的字节数，delete flag为1记录的总字节数
				  PAGE_N_DIRECTION:一个方向连续插入记录的数量
				  PAGE_N_RECS:该页中记录的数量
	3)Infimun和Supremum Records 前者记录该页中笔任何主键值要小的值，后者记录比任何可能大的值还要大的值。
	4)User Records(用户记录及行记录)：行记录的内容
	5)Free Space(空闲空间)：空闲的行的内容
	6)Page Directory(页目录)：
	7)File Trailer(文件结尾信息)：用来保证数据的完整行
6：分区
	mysql支持的分区：分区列必须是唯一索引的一个组成部分，如果没有唯一索引那么任何列都可以分区
	RANGE分区：行数据基于属于一个给定连续区间的列值被放入分区
		partition p0 values less than (10)
		partition p1 values less than (20)这样就是连续的分块的分区
	List分区：和RANGE分区类似，只是LIST分区面向的是离散的值
		partition p0 values in(1,3,5,7,9)
		partition p0 values in(2,4,6,8,10)离散的非连续的
	HASH分区：根据用户定义的表达式的返回值来进行分区，返回值不能是负数
		partition by hash(year(b))
		partitions 4;为了均匀分布到各个分区
	KEY分区：根据MySQL数据库提供的哈希函数来进行分区。
		partition by key(b)
		partitions 4;为了均匀分布到各个分区
7:索引和算法
	B+树索引
		聚集索引：是按照表的主键构建的一个B+树，同时叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。数据页也是索引的一部分，数据页是通过双向链表来进行链接的。
		每张表只有一个聚集索引。查询优化器倾向于采用聚集索引。
		辅助索引（非聚集索引）：叶子节点并不包含记录的全部数据，叶子节点包含键值和书签，书签会告诉InnDB存储引擎哪里可以找到与索引相对应的行数据。
		B+树索引的分裂：目前默认的是50%分裂页的操作，但是如果遇到顺序递增的索引，那么原有页的使用量只有50%，容易造成浪费
		通过记录上一次插入记录的位置和方向决定是否从50%处分裂，并带着上一次记录一起分裂
	B+树的索引管理
		1）可以通过alter table 或者 create /drop index.
		2) 可以通过show index from table查看索引信息
		table:索引所在表
		non_unique:非唯一索引
		key_name:索引的名称
		seq_in_index；索引在该列的位置
		column_name:索引列的名称
		collation:列以什么方式存储在索引中
		cardinality：非常关键的值，标识索引中唯一值数目的预估值，预估值除以行数 尽量要接近1，如果非常小，则可以考虑删除
		sub_part:是否是列的部分被索引，如果为100表示只有此列的前100字符被索引，为null则表示全部被索引
		packed:关键字被压缩，为null则未被压缩
		null:是否允许为null值，值为yes则允许为null
		index_type:索引的类型只支持B树，则值为null
		comment：注释
	索引的使用：
		1）联合索引最左原则2）select * from buy_log where userid = 1 order by by_date desc 可以创建联合索引userid和by_date
		2)覆盖索引，如果查询条件中和查询结果语句不需要聚集索引的话，可能会走覆盖索引，比如：
			1.select count(*) from buy_log，count(*) 和聚集索引的其他数据无关，可以走覆盖索引
			2.select count(*) from buy_log where buy_date>='xx' and buy_date <= 'xx' 可以走覆盖索引
	索引提示
		可以强制指定使用哪个索引：1）mysql错误的使用了索引，非常非常少见2）明确使用哪种索引，减少分析时间
	Multi-Range Read (MMR)优化：
	MMR优化以下几种好处：
	1）MRR是数据库方位较为顺序，在查询辅助索引，根据得到的值按照主键排序，按照主键进行查找
	2）减少缓冲池中页被替换的次数
	3）批量处理对键值的查询操作
	Index Condition Pushdown (ICP)优化
	mysql在取出索引的同时，判断是否可以进行WHERE条件的过滤，也就是将WHERE的部分过滤操作放在了存储引擎层。在某些查询下，可以大大减少上层sql的查询
	可以在查询计划中看到Using index condition提示
	全文索引：是将存储于数据库中的整本书活整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中的章，节，段，句等信息也可以进行各种统计和分析。
	全文索引通常使用倒排索引实现，倒排索引会在辅助表中存储单词与单词自身在一个或者多个文档所在位置的映射。innodb使用的是以下2中方式中第二种方式。
	1）inverted file index 存储的内容为{单词，单词所在文档}比如 code,{1,4},则说明code字符串在文档1，4中
	2）full inverted index 存储的内容为{单词，（单词所在文档，文档的位置）}比如code,{(1,10),(4,5)}：则说明code字符串在文档1中10的位置，在文档4中5的位置。
	innodb全文索引：使用full inverted index的方式，（documntId，position）存放在ilist中，就如上面的例子{（1,10），（4，5）}
	把work存在在一个表中，叫Auxiliary Table（辅助表），为了提供性能根据word的Latin编码进行分区，共6张表。是持久化表。还有另外一个概念FTS Index Cache（全文检索索引缓存）
	FTS Index Cache（全文检索索引缓存）
	是个红黑树，是根据（work,ilist）进行排序。

锁：数据库关键特性，用于管理对共享资源的并发访问。
lock和latch
latch一般被称为闩锁（轻量级锁），一般要求锁定的时间要短，时间长的话性能会变差，在innodb中，分为mutex(互斥锁)和rwlock(读写锁)。保证并发的正确性，通常没有死锁检测机制。
lock锁对象是事务，锁定表页行。并且会在事务提交回滚后释放。lock是有死锁情况的

