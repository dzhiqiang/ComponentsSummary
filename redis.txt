https://segmentfault.com/a/1190000002906345
### redis持久化
redis持久化有2中方式：快照方式（RDB）和追加的方式（AOF文件）

	1. RDB持久化的方式会在一定的时间间隔保存此时间点的一个数据的快照
	2. AOF持久化方式则会记录每一个服务器的写操作，在服务启动时，这些记录的操作会逐条执行从而建出原来的数据。
	写操作命令记录的格式跟redis协议一致，已追加的方式进行保存
	3. 两种方式的持久化是可以同时存在的，但是当redis重启是，AOF文件会被优先用于重建数据

### RDB
### 工作原理
	redis调用fork(),产生一个子进程
	子进程把数据写到一个临时的RDB文件中
	当子进程写完新的RDB文件后，把旧的RDB文件替换掉

### 优点
	RDB文件是一个很简洁的文件，他保存了某个时间点的Redis的数据，很适合用于备份。
	可以设定一个时间点对RDB文件进行归档，这样就能在需要的时候很轻易的把数据恢复到不同的版本。
	基于上面所描述的特性，RDB很适合用于灾备。单文件很方便就能传输到远程的服务器上
	RDB的性能很好，需要进行持久化时，主进程会fork一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的I/O操作。
	比起AOF，在数据量比较大的情况下，RDB的启动速度更快。

### 缺点
	RDB容易造成数据丢失。假设每5分钟保存一次快照，如果Redis因为某些原因不能正常工作，
	那么从上次产生快照到Redis出现问题这段时间的数据就会丢失了。
	RDB使用fork()产生子进程进行数据的持久化，如果数据比较大的话可能就会花点时间，造成Redis停止服务几毫秒。
	如果数据量很大且CPU性能不是很好的时候，停止服务的时间甚至会到1秒
	
### 文件路径和名称
	dbfilename dump.rdb
	
### rdb的启用和禁用
	save 60 1000 如果在60秒内有1000个变动就保存
	默认的配置
	save 900 1 #900秒后至少1个key有变动
	save 300 10 #300秒后至少10个key有变动
	save 60 10000 #60秒后至少10000个key有变动
	想禁用可以配置
	save ""
### 手动生成快照
	save命令会同步的方式生成RDB快照文件。这样的话会阻塞写入
	bgsave命令使用后台的方式保存RDB文件
	
### AOF
快照的方式并不可靠。如果你的电脑宕机了，或者杀掉线程，最新的数据就会丢失，而AOF文件则提供了一种更为可靠的持久化方式。
每当Redis接收到会修改数据集的命令时，就会把命令追加到AOF文件里，当你重启Redis时，AOF里的命令会被重新执行一次，重建数据。

### 优点
	1. 比RDB可靠。你可以定制不同的fsync策略：不进行fsync,每秒fsync和每次执行的时候fsnc.默认是每秒同步一次。意味着最多丢失一秒钟的数据。
	2. AOF日志文件是一个纯追加的文件，就算突然停电的情况，也不会出现日志的定位或者损坏的问题。
	甚至如果因为某些原因命令只写了一半到日志文件里，我们也可以用redis-check-aof这个工具很简单的进行修复
	3. 当AOF过大的时候，Redis也会进行重写，重写很安全，因为重写是在一个新的文件上进行，同时Redis会继续往旧的文件追加数据。
	新文件上会写入能重建当前数据集的最小操作命令的集合。当新文件重写完，Redis会把新旧文件进行切换，然后开始把数据写到新文件上。
	4. AOF把操作命令比较简单的方式存储到文件中，即使执行了FLUSHAL命令把所有数据刷掉了，只要文件没有被重写，那么把服务停掉，
	把文件最后的命令删除，数据就会回来的

### 缺点
	在相同的数据集下，AOF文件的大小一般都会比RDB文件大
	在某些fsync策略下，AOF的速度会比RDB慢，通常fsync设置成每秒一次就能获取比较高的性能，而在禁用fsync的情况下速度可以达到RDB水平
	在过去曾发现一些bug,导致AOF无法重建

### 启用AOF
	appendonly yes

### AOF调用的三个选项，推荐一秒一次
	appendfsync always 每当有新命令追到AOF的时候调用fsync,速度最慢，最安全
	appendfsync everysec 每秒fsync一次。速度快，安全性不错。最多丢失1秒的数据。
	appendfsync no 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般。



	
	


​	